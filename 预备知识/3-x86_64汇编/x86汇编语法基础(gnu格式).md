# x86汇编语法基础(gnu格式)

文章转载自: 

- [Coder Heart: x86汇编语法基础](https://juejin.cn/post/7195191160603115580)

## 1. 寄存器

### 1.1 通用寄存器

x86_64 CPU包含16个64位的通用寄存器。另外，这些寄存器的低32位、16位、8位都可以作为独立的寄存器来进行访问。

![x64-registers](https://raw.githubusercontent.com/ivanzz1001/linux-kernel-learning/master/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/3-x86_64%E6%B1%87%E7%BC%96/image/x64_registers.png)

1. **caller-save registers**

    `%rax` , `%rcx` , `%rdx` , `%rdi` , `%rsi` , `%rsp` , `%r8-r11` 通常被认为是caller-save寄存器， 其中：

      - `%rax` 通常用于保存函数的返回值

      - `%rcx` 通常用于保存函数调用时的第4个参数

      - `%rdx` 通常用于保存函数调用时的第3个参数

      - `%rsi` 通常用于保存函数调用时的第2个参数

      - `%rdi` 通常用于保存函数调用时的第1个参数

      - `%rsp` 用于保存栈指针，指向当前栈顶元素

      - `%r8` 通常用于保存函数调用时的第5个参数

      - `%r9` 通常用于保存函数调用时的第6个参数

1. **callee-save registers**

    `%rbx` , `%rbp` , `%r12-r15`通常被认为是callee-save寄存器，其中：

      - `%rbp` 保存栈基址


>Tips: 当指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节如何处理，有两条规则
>
> - 生成1字节和2字节数字的指令会保持剩下的字节不变
> - 生成4字节的指令会把高位4字节置为0
>
> 后面这条规则是作为从IA32到x86-64的扩展的一部分而采用的

### 1.2 标志寄存器EFLAGS

EFLAGS标志寄存器包含有`状态标志位`、`控制标志位`以及`系统标志位`， 处理器在初始化时将EFLAGS标志寄存器赋值为00000002H (325462-sdm-vol-1-2abcd-3abcd-4-1.pdf#Page 80)。

下图描绘了EFLAGS标志寄存器各位的功能，其中第1, 3, 5, 15以及22-31位保留未使用。由于64位模式不再支持VM和NT标志位，所以处理器不应该再置位这两个标志位。

![x64-registers](https://raw.githubusercontent.com/ivanzz1001/linux-kernel-learning/master/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/3-x86_64%E6%B1%87%E7%BC%96/image/x64-elfags.awebp)

>TIPs：在64位模式中，EFLAGS标志寄存器已从32位扩展为64位，被称作RFLAGS寄存器。其中高32位保留未使用，低32位与EFLAGS相同

接下来, 我们会根据标志位功能将`EFLAGS`划分为`状态标志`、`方向标志`、`系统标志`和`IOPL区域`等几个部分，并对各部分的标志位功能进行逐一讲解。（请参考Intel官方白皮书Volumn 1的3.4.3节）


#### 1.2.1 状态标志

EFLAGS标志寄存器的状态标志(位0, 2, 4, 6, 7和11)可以反映出汇编指令计算结果的状态，像add, sub, mul, div等汇编指令计算结果的奇偶性、溢出状态、正负值皆可从上述状态找那个反映出来。

1. `CF`

    进位标志，全称为Carry Flag，位于bit 0。运算中，当数值的最高位产生了进位或者借位，CF位都会置1，否则为0。它可用于检测无符号整数运算结果是否溢出。也可用于多精度运算中。

1. `PF`

    奇偶标志，全称为Parity Flag，位于bit 2。用于标记结果低8位中1的个数，如果为偶数， PF位为1，否则为0 。注意，是最低的那8位，不管操作数是16位，还是32位。奇偶校验经常用于数据传输开始时和结束后的对比，判断传输过程中是否出现错误。

1. `AF`

    辅助进位标志，全称为Auxiliary Carry Flag，位于bit 4。辅助进位标志，用来记录运算结果低4位的进、借位情况，即若低半字节有进、借位，AF为1，否则为0。

1. `ZF`

    零值标志，全称为Zero Flag，位于bit 6。若计算结果为0，此标志位置1，否则为0。

1. `SF`

    符号标志，全称为Sign Flag，位于bit 7。若运算结果为负，则SF位为1，否则为0。

1. `OF`

    溢出标志，全称为Overflow Flag，位于bit 11。用来标识计算的结果是否超过了数据类型可以表示的范围，若OF为1，表示有溢出，为0则未溢出。专门用于检测有符号整数运算结果是否溢出。

这些标志位可反映出三种数据类型的计算结果：无符号整数、有符号整数和BCD整数（Binary-coded decimal integers）。其中：

- CF标志位： 可反映出无符号整数运算结果的溢出状态；

- OF标志位： 可反映出有符号整数（补码表示）运算结果的溢出状态；

- AF标志位： 表示BCD整数运算结果的溢出状态；

- SF标志位： 反应出有符号整数运算结果的正负值；

- ZF标志位： 反映出有符号或无符号整数运算的结果是否为0。

以上这些标志位，只有CF标志位可通过stc、clc和cmc（Complement Carry Flag，计算原CF位的补码）汇编指令更改位值。它也可借助位操作指令（bt、bts、btr和btc指令）将指定位值复制到CF标志位。而且，CF标志位还可在多倍精度整数计算时，结合adc指令（含进位的加法计算）或sbb指令（含借位的减减法）将进位计算或借位计算扩展到下次计算中。

至于状态跳转指令Jcc、状态字节置位指令SETcc、状态循环指令LOOPcc以及状态移动指令CMOVcc，它们可将一个或多个状态标志位作为判断条件，进程分支跳转、字节置位以及循环计数。

#### 1.2.2 方向标志

DF方向标志位（Direction Flag）位于EFLAGS标志寄存器的第 10 位，它控制着字符串指令（诸如movs、cmps、scas、lods、stos等）的操作方向。置位DF标志位可使字符串指令按从高到低的地址方向（自减）操作数据，复位DF标志位可使字符串指令按从低到高的地址方向（自增）操作数据。汇编指令std和cld可用于置位和复位DF方向标志。

#### 1.2.3 系统标志和IOPL区域

1. `TF位`

    第 8 位为TF位，即Trap Flag，意为陷阱标志位。此位若为1，用于让CPU进入单步运行方式，若为0，则为连续工作的方式。平时我们用的debug程序，在单步调试时，原理上就是让TF位为1。

1. `IF位`

    第 9 位为IF位，即Interrupt Flag，意为中断标志位。若IF位为1，表示中断开启，CPU可响应外部可屏蔽中断。若为0，表示中断关闭，CPU不再响应来自CPU外部的可屏蔽中断，但CPU内部的异常还是要响应的。

1. `IOPL位`
    第 12-13 位为IOPL，即 Input Output Privilege Level，这用在有特权级概念的CPU中。有4个任务特权级，即特权级0-3，故IOPL要占用2位来表示这4种特权级。

 1. `NT位`   

    第 14 位为NT，即 Nest Task，意为任务嵌套标志位。8088支持多任务，一个任务就是一个进程。当一个任务中又嵌套调用了另一个任务时，此NT位为1，否则为0。

1. `RF位`

    第 16 位为RF位，即 Resume Flag，意为恢复标志位。该标志位用于程序调试，指示是否接受调试故障，它需要与调试寄存器一起使用。当RF为1时忽略调试故障，为0时接受。

1. `VM位`

    第 17 位为VM位，即 Virtual 8086 Model，意为虚拟8086模式。

1. `AC位`

    第 18 位为AC位，即 Alignment Check / Access Control，意为对齐检查。若AC位为1时，则进行地址对齐检查，位0时不检查。

1. `VIF位`

    第 19 位为VIF位，即 Virtual Interrupt Flag，意为虚拟中断标志位，虚拟模式下的中断标志。

1. `VIP位`

    第 20 位为VIP位，即 Virtual Interrupt Pending Flag，意为虚拟中断挂起标志位。在多任务情况下，为操作系统提供的虚拟中断挂起信息，需要与 VIF 位配合。

1. `ID位`   

    第 21 位为ID位，即 Identification Flag，意为识别标志位。系统经常要判断CPU型号，若ID位为1，表示当前CPU支持CPUID指令，这样便能获取CPU的型号、厂商信息等；若ID位为0，则表示当前CPU不支持CPUID指令。

### 1.3 段寄存器

参看：`325462-sdm-vol-1-2abcd-3abcd-4-1.pdf#Page 77`

x86-64架构，拥有6个16位段寄存器，用于保存segment selectors。segment selector是一种特殊的指针，用于标识内存中的段。要访问内存中的特定段，该段的segment selector必须存在于相应的段寄存器中。 

在平坦内存模型中，段选择子指向线性地址空间的地址0；在分段内存模型中，每个分段寄存器通常加载有不同的segment selector，以便每个分段寄存器指向线性地址空间内的不同分段。如下图所示：

![segment-model](https://raw.githubusercontent.com/ivanzz1001/linux-kernel-learning/master/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/3-x86_64%E6%B1%87%E7%BC%96/image/segment-model.png)

每一个段寄存器表示三种存储类型之一：代码，数据，栈。

1. `CS寄存器`

    CS段寄存器保存着代码段的segment selector。CPU会从代码段寄存器中保存的segment selector 和 `RIP/EIP`寄存器内容生成的线性地址处来执行指令。RIP/EIP寄存器存储的是下一条要执行的指令在代码段上的偏移。

1. `DS/ES/FS/GS寄存器`

    这四个寄存器分别指向了4个数据段，用于高效、安全的访问不同类型的数据结构。

1. `SS寄存器`

    SS寄存器包含栈段（stack segment）的segment selector，其中存储当前正在执行的程序、任务或处理程序的过程堆栈。

### 1.4 控制寄存器

目前，Intel处理器共拥有6个控制寄存器（CR0、CR1、CR2、CR3、CR4、CR8），它们有若干个标志位组成，通过这些标志位可以控制处理器的运行模式、开启扩展特性以及记录异常状态等功能。

### 1.5 指令指针寄存器

RIP/EIP寄存器，即指令指针寄存器，有时称为程序计数器。指令指针（RIP/EIP）寄存器包含当前代码段中要执行的下一条指令的偏移量。

### 1.6 MSR寄存器组

MSR（Model-Specific Register）寄存器组可提供性能监测、运行轨迹跟踪与调试以及其它处理器功能。在使用MSR寄存器组之前，我们应该通过CPUID.01h:EAX[5]来检测处理器是否支持MSR寄存器组。处理器可以使用RDMSR和WRMSR对MSR寄存器组进行访问，整个访问过程借助ECX寄存器索引寄存器地址，再由EDX:EAX组成的64位寄存器保持访问值。（在处理器支持64位模式下，RCX、RAX和RDX寄存器的高32位将会被忽略）。

---

## 2. 指令集

### 2.1 操作数和指令后缀

#### 2.1.1 操作数

x86指令可以有0到3个操作数，多个操作数之间以逗号分割。对于有两个操作数的指令，第一个源操作数，第二个是目的操作数，指令的执行结果保存到第二个操作数表示的寄存器或内存地址中。

源数据值可以以常数形式给出，或是从寄存器或内存中读取。结果可以存放在寄存器或内存中。因此，操作数被分为三种类型：

1. `立即数(immediate)`

    用来表示常数值。立即数通过在正数前加一个`$`来表示。例如`$-577`或者`$0x1F`

1. `寄存器(register)`

    它表示某个寄存器的内容，通过在寄存器名声前加上`%`来表示。比如：`%eax`或 `%al`

1. 内存引用

    它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。内存引用的语法:

    ```text
    segment:offset(base, index, scale) 
    ```

    其中:

      - segment: 可以是 x86 架构的任意段寄存器。segment 是可选的，如果指定的话，后面要跟上冒号来与offset隔离开； 如果未指定的话，默认为数据段寄存器`%ds`

      - offset: 是一个立即数偏移量，是可选的。

      - base： 表示基址寄存器，可以是16个通用寄存器中的任意一个

      - index: 表示变址寄存器，可以是16个通用寄存器中的任意一个

      - scale: 表示比例因子，scale会与index相乘再加上base来表示内存地址。比例因子必须是1,2,4或者8；若比例因子为指定，默认为1

    有效地址被计算为：`D[segment]+offset+R[base]+R[index]*scale`，其中`D[]`表示对应段寄存器的数据; `R[]`表示通用寄存器里的数。我们用`M[addr]`来表示内存地址addr。

    <br>

    内存地址操作示例：

    ```text
    指令                           说明
    ----------------------------------------------------------------------
    movl var, %eax                 把内存地址M[var]处的数据传送到eax寄存器
    movl %cs:var, %eax             把代码段偏移量为var处的内存数据传送到eax寄存器
    movl $var, %eax                把立即数var传送到eax寄存器
    movl var(%esi), %eax           把内存地址 M[R[%esi] + var] 处的数据传送到eax寄存器
    movl (%ebx, %esi, 4), %eax     把内存地址 M[R[%ebx] + R[%esi]*4] 处的数据传送到eax寄存器
    movl var(%ebx, %esi, 4), %eax  把内存地址 M[var+R[%ebx] + R[%esi]*4] 处的数据传送到eax寄存器
    ```

#### 2.1.2 指令后缀

由于是从16位体系结构扩展成32位的，Intel用术语“字（word）”表示16位数据类型。因此，称32位为“双字（double words）”，称64位数为“四字（quad words）”。标准int值存储为双字（32位）。指针存储为8字节的四字。x86-64中，数据类型long实现为64位。x86-64指令集同样包括完整的针对字节、字和双字的指令。

下表给出了C语言基本数据类型对应的x86-64表示。在64位机器中，指针长8字节。

```text
C声明	   Intel数据类型	   汇编代码后缀	    大小（字节）
--------------------------------------------------------------
char     字节             b               1
short    字               w               2
int      双字             l               4
long     四字             q               8
char *   四字(指针)       q               8
float    单精度           s               4
double   双精度           l               8
```
浮点数主要有两种形式：单精度（4字节）值，对应于C语言数据类型float；双精度（8字节）值，对应于C语言数据类型double。

如上表所示，大多数汇编代码指令都有一个字符的后缀，表明操作数的大小。例如：数据传送指令有四个变种：movb（传送字节）、movw（传送字）、movl（传送双字）和movq（传送四字）。注意，虽然汇编代码使用后缀“l”来表示4字节整数和8字节浮点数，但并不会产生歧义，因为浮点使用的是一组完全不同的指令和寄存器。

### 2.2 数据传送指令

#### 2.2.1 简单传送指令

最简单形式的数据传送指令是MOV类。这些指令把数据从源位置复制到目的位置，不做任何变化。MOV类由四条指令组成：movb、movw、movl和movq。这些指令都执行同样的操作，主要区别在于他们操作的数据大小不同：分别是1、2、4和8字节。下表列出了MOV类指令：

```text
指令             效果	           描述
----------------------------------------------------------
MOV S, D         S → D          传送
movb                            传送字节
movw                            传送字
movl                            传送双字
movq                            传送四字
movabsq I, R     I → R	        传送绝对的四字
```

源操作数指定的值是一个立即数，存储在寄存器或者内存中。目的操作数指定一个位置，可以是寄存器或内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。大多数情况下，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。

movabsq指令是处理64位立即数数据的。常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。movabsq指令能够以任意64位立即数作为源操作数，并且只能以寄存器作为目的。

代码示例：

```text
movl $0x4050, %eax              # 立即数 --> 寄存器，4字节
movw %bp, %sp                   # 寄存器 --> 寄存器，2字节
movb (%rbi, %rcx), %al          # 内存 --> 寄存器，1字节
movb $-17, (%rsp)               # 立即数 --> 内存，1字节
movq %rax, -12(%rap)            # 寄存器 --> 内存，8字节
```

1. **理解数据传送如何改变目的寄存器**

    ```text
    movabsq $0x0011223344556677, %rax   # %rax = 0x0011223344556677
    movb    $-1, %al                    # %rax = 0x00112233445566FF
    movw    $-1, %ax                    # %rax = 0x001122334455FFFF
    movl    $-1, %eax                   # %rax = 0x00000000FFFFFFFF
    movq    $-1, %rax                   # %rax = 0xFFFFFFFFFFFFFFFF
    ```
    
    在这个例子中，第一行的指令把寄存器%rax初始化为位模式 0011223344556677。剩下的指令源操作数是立即数-1。因此 movb 指令把%rax的低位字节设置为 FF，而 movw 指令把低 2 位字节设置为 FFFF，剩下的字节保持不变。movl 指令将低 4 个字节设置为 FFFFFFFF，同时把高位 4 字节设置为 00000000。最后 movq 指令把整个寄存器设置为 FFFFFFFFFFFFFFFF。

#### 2.2.2  扩展传送指令

MOVZ和MOVS是另外两类数据移动指令，在将较小的源值复制到较大的目的时使用。MOVZ类中的指令把目的中剩余的字节填充位0，而MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。这两类指令分别如下表所示:

1. **零扩展的传送指令**

    ```text
    指令            效果               描述
    -----------------------------------------------------------------------
    MOVZ S, R      零扩展(S) → R       以零扩展进行传送
    movzbw                            将做了零扩展的字节传送到字
    movzbl                            将做了零扩展的字节传送到双字
    movzbq                            将做了零扩展的字节传送到四字
    movzwl                            将做了零扩展的字传送到双字
    movzwq                            将做了零扩展的字传送到四字
    ```

1. **符号扩展的传送指令**

    ```text
    指令            效果               描述
    -----------------------------------------------------------------------
    MOVS S, R      符号扩展(S) → R     传送符号扩展的字节
    movsbw                            将做了符号扩展的字节传送到字
    movsbl                            将做了符号扩展的字节传送到双字
    movsbq                            将做了符号扩展的字节传送到四字
    movswl                            将做了符号扩展的字传送到双字
    movswq                            将做了符号扩展的字传送到四字
    ```

1. **位扩展传送指令**

    ```text
    指令        效果                                  描述
    ---------------------------------------------------------------------
    cbtw       符号扩展(R[%al]) → R[%ax]              把%al符号扩展到%ax
    cwtl       符号扩展(R[%ax]) → R[%eax]             把%ax符号扩展到%eax
    cwtd       符号扩展(R[%ax]) → R[%dx]: R[%ax]      把%ax符号扩展到%dx:%ax
    cltq       符号扩展(R[%eax]) → R[%rax]            把%eax符号扩展到%rax
    cltd       符号扩展(R[%eax]) → R[%edx]: R[%eax]   把%eax符号扩展到%edx:%eax
    cqto       符号扩展(R[%rax]) → R[%rdx]: R[%rax]   把%rax符号扩展为八字
    cqtd       符号扩展(R[%rax]) → R[%rdx]: R[%rax]   把%rax符号扩展为八字
    ```

<br>

**字节传送指令比较**

```text
movabsq $0x0011223344556677, %rax   # %rax = 0x0011223344556677
movb    $0xAA, %dl                  # %dl = 0xAA
movb    %dl, %al                    # %rax = 0x00112233445566AA
movsbq  %dl, %rax                   # %rax = 0xFFFFFFFFFFFFFFAA
movzbq  %dl, %rax                   # %rax = 0x00000000000000AA
```
代码的头 2 行将寄存器 %rax 和 %dl 分别初始化为 0x0011223344556677 和 0xAA。剩下的指令都是将 %rdx的低位字节复制到 %rax的低位字节。movb 指令不改变其它字节。根据源字节的最高位，movsbq 指令将其它 7 个字节设为全 1 或全 0。由于十六进制 A 表示的二进制值为 1010，符号扩展会把高位字节都设置为 FF。movzbq 指令总是将其它 7 个字节全都设置为 0。


#### 2.2.3 压入和弹出栈数据

栈相关指令如下表所示:

```text
指令	        效果                      	              描述
----------------------------------------------------------------------------
pushq S	      R[%rsp]-8 → R[%rsp]; S → M[R[%rsp]]	     将四字压入栈
popq D	      M[R[%rsp]] → D; R[%rsp] + 8 → R[%rsp]	   将四字弹出栈
```

pushq 指令的功能是把数据压入到栈上，而 popq 指令是弹出数据。这些指令都只有一个操作数--压入的数据源和弹出的数据目的。

将一个四字值压入栈中，首先要将栈指针减 8，然后将值写到新的栈顶地址。因此，指令 pushq %rbp的行为等价于下面两条指令：

```text
subq $8, %rsp
movq %rbp, (%rsp)
```

弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加 8。因此，指令 popq %rax 等价于下面两条指令:

```text
movq (%rsp), %rax
addq $8, %rsp
```

#### 2.2.4 加载有效地址

leaq 指令格式如下:

```text
指令           效果           描述
----------------------------------------------
leaq S, D      &S → D        加载有效地址
```

加载有效地址（load effective address）指令 leaq 实际上是 movq 指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令不是从指定的位置读入数据，而是将有效地址写入到目的操作数。例如，如果寄存器 %rdx 的值为 x，那么指令`leaq 7(%rdx, %dx, 4)`, %rax将寄存器 %rax 的值为 `5x+7`。

